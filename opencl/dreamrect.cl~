__kernel void das_beamfomer_update(__global double *o_p,
                                   __global const double *y_p,
                                   int a_scan_len,
                                   int num_a_scans,
                                   __global const double *ro,
                                   int No,
                                   int holdoff,
                                   double cp,
                                   double Fs,
                                   double pitch)
{




__kernel void dreamrect(__global double *Ro
                        double a,
                        double b,
                        double dx,
                        double dy,
                        double dt,
                        int nt,
                        double delay,
                        double v,
                        double cp,
                        double alpha,
                        double *h)
{
  dream_idx_type i, it;
  double t;
  double ai, ds, pi;
  double ri, x, y;
  double xsmin, xsmax, ysmin, ysmax;
  int err = NONE;
  double rx,ry,rz;

  xsmin = -a/2.0;
  xsmax =  a/2.0;
  ysmin = -b/2.0;
  ysmax =  b/2.0;

  pi = atan( (double) 1.0) * 4.0;
  ds = dx * dy;

  for (i = 0; i < nt; i++)
    h[i] = (double) 0.0;

  // Check if absorbtion is present.
  if (alpha == (double) 0.0) {

    rz = zo;
    y = ysmin + dy / 2.0;

    while (y <= ysmax) {
      ry = yo - y;
      x = xsmin + dx / 2.0;

      while (x <= xsmax) {

        rx = xo - x;
        ri = sqrt(rx*rx + ry*ry + rz*rz);

        ai = v * ds / (2*pi * ri);
        ai /= dt;
        ai *= 1000.0;		// Convert to SI units.

        t = ri * 1000.0/cp;	// Propagation delay in micro seconds.
        it = (dream_idx_type) rint((t - delay)/dt); // Sample index.

        // Check if index is out of bounds.
        if ( (it < nt) && (it >= 0) ) {
          h[it] += ai;
        }

        x += dx;
      }
      y += dy;
    }

  }







  const int N_tx = 128; // Current dolphicam2 TRMs
  const int N_rx = 128;
  const double aperture = 32.0; // Current dolphicam2 TRMs

  // Get the index of the current element to be processed
  int no = get_global_id(0);


  double dt = 1.0/((Fs)*1.0e6);

  //
  // Beamform the (upsampled) data.
  //

  // Ro is an No x 3 matrix. TODO: Should we compute these on-the-fly instead?
  double x = ro[no];
  double y = ro[no + No*1];
  double z = ro[no + No*2];

  o_p[no] = 0.0;
  double o_local = 0.0;

  //
  // Loop over all A-scans
  //

  //double x_tx = -aperture/2.0 + pitch/2.0 + ((double) n_tx)*pitch;

  double x_tx = -aperture/2.0 + pitch/2.0;
  for (int n_tx=0; n_tx<N_tx; n_tx++) {

    // Tx
    // When Tx is a thin stripe.
    double rx = x - x_tx;
    //double ry = y - y;
    //double rz = z - 0.0;
    //double r_tx = sqrt(rx*rx + ry*ry + rz*rz);
    double r_tx = sqrt(rx*rx + z*z);

    double y_rx = -aperture/2.0 + pitch/2.0;

    for (int n_rx=0; n_rx<N_rx; n_rx++) {

      // Rx
      // When Rx is a thin stripe.
      //double rx = x - x;
      double ry = y - y_rx;
      //double rz = z - 0.0;
      //double r_rx = sqrt(rx*rx + ry*ry + rz*rz);
      double r_rx = sqrt(ry*ry + z*z);

      double r = r_tx + r_rx; // Double-path distance.

      //int k = rint((r*1e-3/cp)/dt) - holdoff;
      int k = ((int) ((r*1e-3/cp)/dt)) - holdoff; // Slightly faster without rint().

      if ( (k < a_scan_len) && (k>=0) ) {
        //o_p[no] += y_p[k];
        o_local += y_p[k];
        //o_p[no] += y_p[k + a_scan_len*(n_rx + N_rx*n_tx)];
        //o_local[n_tx] += y_p[k + a_scan_len*(n_rx + N_rx*n_tx)];
      }

      y_p += a_scan_len;      // Jump to the next A-scan

      y_rx += pitch;
    }
    x_tx += pitch;
  }

  // Just touch global memory once!
  o_p[no] = o_local;

    // Make sure all local workers are done.
    //barrier(CLK_LOCAL_MEM_FENCE);

  /*
    // Let the last worker in the group sum all contributions.
    if (n_tx == 127) {
      o_p[no] = 0.0;
      for (int n=0; n<N_tx; n++) {
        o_p[no] += o_local[n];
      }
    }
  */
}
